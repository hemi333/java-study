C / 절차 지향
C++ / 절차 지향에 객체 지향 추가
java / 객체 지향

- 절차 지향

* 순서대로 개발
* 문제점 : 수정사항이 있을 때 마다 전부 뜯어 고쳐야 함

- 객체 지향

* 클래스가 표현 단위

객체 지향 프로그래밍(Object Oriented Programming)

- OOP

### < 객체 지향 3가지 요소 >

- 캡슐화(Encapsulation) -> 클래스
- 상속(Inheritance)
- 다형성(Polymorphism)

### < 클래스(Class) >

- 객체 지향을 구현하는 것 (객체의 속성을 정의)
- 구성 요소:
  --- 속성: 변수
  --- 기능: 메서드
  ex)
  class -> TV
  변수 -> 너비, 길이, 높이, 색상, 볼륨, 채널 등
  메서드 -> 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기 등

- 속성 -> 멤버 변수: name, no, balance (클래스 내부의 정보)
- 기능 -> 멤버 메서드: getter/setter, deposit, withdraw
- 생성자

default 생성자 - 매개변수가 없는 생성자

1. class를 만들면 무조건 생성
2. 다른 생성자를 만들면 디폴트 생성자는 사라짐

- 오버라이딩(메서드 재정의) : 상속받은 메소드의 내용을 변경
  - 상속으로 인해 동일한 이름의 메소드가 여러 개인 경우 자식 클래스의 메서드만 사용됨.
- 오버로딩 (Overloading) : 기존에 없는 새로운 메소드를 정의
  - 메소드의 이름은 동일하지만 인수를 받는 자료형과 개수가 다르면 서로 다른 메소드임.
    이름은 같지만 자료형 개수를 다르게 하여 여러 기능은 정의하는 것.

### < 메서드 오버로딩(Method Overloading) >

- 메서드 중복 정의
- 메서드의 이름은 같지만, 매개변수의 개수 또는 타입을 다르게 정의하는 것
- 주의) 매개변수의 이름과 리턴타입은 오버로딩에 포함되지 않음
- 오버로딩을 왜 써야함? 이름을 다르게 하면 되잖아 -> 협업을 위해서!(매뉴얼을 찾아보는 시간 발생)
- 찾아볼 필요 없이 만들어져 있으면 그냥 호출하면 되니까

### < 멤버 접근 페이지(한정자), access modifier >

- private : 같은 클래스의 멤버만 사용이 가능
- default : 같은 패키지 내에서만 사용이 가능, 접근 제어자를 쓰지 않은 상태
- protacted : 상속을 받은 자식 클래스에서 사용이 가능
- public : 어디에서나 사용이 가능, public을 쓸 수 있는 클래스는 파일명과 일치하는 클래스 뿐이다. 그 외의 클래스에서 사용시 에러 발생

★★★★★ 중요!

### < 생성자 오버로딩 >

생성자 (constructor) - 인스턴스가 생성될 때 사용되는 인스턴스 초기화 메소드 (new 와 같은 키워드로 해당 클래스의 인스턴스가 새로 생성될 때, 자동으로 호출되는 메소드)
생성자의 특징: class명과 동일, 리턴타입이 없음
생성자의 목적: 멤버변수의 확실한 초기화의 보장
생성자의 호출 시기: 인스턴스를 생성할 때만 호출
★매개변수와 멤버변수가 같으면 매개변수에 매개변수를 넣어주기 때문에 금지! (this 붙여야 함)

accessor - getter/setter 메서드를 한꺼번에 부를 때
setter 메서드 - set 멤버변수명을 가진 메서드들, 값을 설정하는 역할
getter 메서드 - get 멤버 변수명을 가진 메서드들, 값을 획득(return)하는 역할
